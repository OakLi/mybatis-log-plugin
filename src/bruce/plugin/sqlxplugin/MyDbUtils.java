package bruce.plugin.sqlxplugin;


import com.google.common.base.CaseFormat;
import com.google.common.collect.Lists;
import com.intellij.database.model.DasColumn;
import com.intellij.database.model.DasTableKey;
import com.intellij.database.model.DasTypedObject;
import com.intellij.database.model.MultiRef;
import com.intellij.database.psi.DbTable;
import com.intellij.database.util.DasUtil;

import com.intellij.util.containers.JBIterable;
import org.jetbrains.annotations.NotNull;


import java.sql.Types;
import java.util.List;

/**
 * @author bruce ge
 */
public class MyDbUtils {
    @NotNull
    public static IntellijTableInfo buildIntellijTableInfoFromDatabase(DbTable currentTable) {
        IntellijTableInfo tableInfo = new IntellijTableInfo();
        tableInfo.setTableName(currentTable.getName());
        tableInfo.setDatabaseType(extractDatabaseTypeFromUrl(currentTable));
        tableInfo.setTableRemark(currentTable.getComment());
        tableInfo.setTableType(currentTable.getTypeName());


        List<IntellijColumnInfo> intellijColumnInfos = Lists.newArrayList();

        JBIterable<? extends DasColumn> columns = DasUtil.getColumns(currentTable);
        for (DasColumn column : columns) {
            IntellijColumnInfo columnInfo = convertColumnToIntellijColumnInfo(column, tableInfo.getDatabaseType());
            // 原始列对象
            intellijColumnInfos.add(columnInfo);
        }

        tableInfo.setColumnInfos(intellijColumnInfos);

        List<IntellijColumnInfo> primaryColumnInfos = Lists.newArrayList();

        DasTableKey primaryKey = DasUtil.getPrimaryKey(currentTable);
        if (primaryKey != null) {
            MultiRef<? extends DasTypedObject> columnsRef = primaryKey.getColumnsRef();
            MultiRef.It<? extends DasTypedObject> iterate = columnsRef.iterate();
            short s = 0;
            while (iterate.hasNext()) {
                String columnName = iterate.next();
                for (IntellijColumnInfo intellijColumnInfo : intellijColumnInfos) {
                    if (columnName.equals(intellijColumnInfo.getName())) {
                        IntellijColumnInfo info = MyCloner.getCloner().deepClone(intellijColumnInfo);
                        info.setKeySeq(s);
                        primaryColumnInfos.add(info);
                        s++;
                        break;
                    }
                }
            }
        }
        tableInfo.setPrimaryKeyColumns(primaryColumnInfos);
        return tableInfo;
    }

    private static String extractDatabaseTypeFromUrl(DbTable currentTable) {
        String url1 = currentTable.getDataSource().getConnectionConfig().getUrl();
        return extractDatabaseTypeFromUrl(url1);
    }


    public static String extractDatabaseTypeFromUrl(String url1) {
        if (url1 == null) {
            return "";
        }
        String url = url1.toLowerCase();
        if (url.contains(":mysql")||url.contains("mariadb")) {
            return DataBaseConstants.MYSQL;
        } else if (url.contains(":oracle")) {
            return DataBaseConstants.ORACLE;
        } else if (url.contains(":postgresql")) {
            return DataBaseConstants.PostgreSQL;
        } else if (url.contains(":sqlserver")) {
            return DataBaseConstants.SqlServer;
        } else if (url.contains(":sqlite")) {
            return DataBaseConstants.SQLITE;
        }
        return "";
    }

    @NotNull
    public static IntellijColumnInfo convertColumnToIntellijColumnInfo(DasColumn column, String databaseType) {
        IntellijColumnInfo columnInfo = new IntellijColumnInfo();
        columnInfo.setName(column.getName());
        // TODO: 7/31/2018 what to do without jdbcType
        columnInfo.setDataType(convertTypeNameToJdbcType(column.getDataType().typeName, column.getDataType().size, databaseType));

        columnInfo.setColumnTypename(column.getDataType().typeName);

        if(DasUtil.isAuto(column)){
            columnInfo.setAutoIncrement(true);
        }
        //todo what means current is auto increment
        if (DasUtil.isAutoGenerated(column)) {
            columnInfo.setGeneratedColumn(true);
        }
        columnInfo.setSize(column.getDataType().getLength());
        columnInfo.setDecimalDigits(column.getDataType().getScale());
        columnInfo.setRemarks(column.getComment());
        columnInfo.setColumnDefaultValue(column.getDefault());
        columnInfo.setNullable(!column.isNotNull());
        // TODO: 7/31/2018 need fix this
        columnInfo.setKeySeq(column.getPosition());
        return columnInfo;
    }

    private static int convertTypeNameToJdbcType(String typeName, int size, String databaseType) {
        return MyJdbcUtils.convertFromJdbcTypeName(typeName, size, databaseType);
    }


    static String convertType(int dataType) {
        //todo later.
         switch (dataType){
             case Types.INTEGER : return "int32";
             case Types.BIGINT: return "int64";
             case Types.BIT: return "bool";
             case Types.TINYINT: return "int8";
             case Types.SMALLINT: return "int16";
             case Types.FLOAT: return "float32";
             case Types.REAL: return "float32";
             case Types.DOUBLE: return "float64";
             case Types.NUMERIC: return  "float64";
             case Types.DECIMAL: return  "float64";
             case Types.CHAR: return "string";
             case Types.VARCHAR: return "string";
             case Types.LONGVARCHAR: return "string";
             case Types.DATE: return "time.Time";
             case Types.TIME: return "time.Time";
             case Types.TIMESTAMP: return "time.Time";

             case Types.BOOLEAN: return "bool";
             case Types.NCHAR: return "string";
             case Types.NVARCHAR: return "string";
             case Types.LONGNVARCHAR: return "string";
//             case Types.NCLOB: return ;
//             case Types.SQLXML: return ;
//             case Types.REF_CURSOR: return ;
             case Types.TIME_WITH_TIMEZONE: return "time.Time";
             case Types.TIMESTAMP_WITH_TIMEZONE: return "time.Time";

//             case Types.BINARY: return ;
//             case Types.VARBINARY: return ;
//             case Types.LONGVARBINARY: return ;
//             case Types.STRUCT: return ;
//             case Types.ARRAY: return ;
//             case Types.BLOB: return ;
//             case Types.CLOB: return ;
         }
        return "int";
    }

    static String underScoreToCamel(String name) {
        return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, name);
    }
}
